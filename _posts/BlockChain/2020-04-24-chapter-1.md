---
title: "[정보보호이론] Chapter 1 현대암호"
excerpt: "컴퓨터 통신 보안"
date: 2020-04-24
categories:
  - BlockChain
tags:
  - blockcahin
toc : true
toc_label: "Table of contents"
toc_icon: "list"  # corresponding Font Awesome icon name (without fa prefix)
toc_sticky: true
---

## 단순 DES

1. 교육용 알고리즘
  - 8비트 평문 블럭과 10비트 키를 사용

![bc-7](/assets/images/blockchain/bc-7.jpg)  

1. 기본함수
  - IP : Initial Permutation : 초기 순열
  - f_{k} 함수
    - transposition | permutation : 전치
    - substitution : 치환
    - 키 입력에 의존
  - SW : swap : 데이터의 두 절반을 상호 교환하는 함수
  - f_{k}^{-1} : 초기 순열의 역인 순열 함수
1. 알고리즘
  - IP^{-1} * f_{k2} * SW * f_{k1} * IP
1. 암호화
  - Ciphertext = IP^{-1}(f_{k2}(SW()))

![bc-8](/assets/images/blockchain/bc-8.jpg)  

### Key Generation

첫 번째 그림의 Key Generation을 자세히 보면 아래와 같습니다.  

![bc-9](/assets/images/blockchain/bc-9.jpg)  

위 그림의 LS는 `LeftShit`를 의미합니다. LS-1과 LS-2는 각각 LeftShift 1bit LeftShift 2bit를 의미합니다. 화살표의 /표시는 몇 bit인지를 나타냅니다.  

```cpp
//left shift 1 bit
int arr[10];
for(int i=0; i<10; i++){
  cin>> arr[i];
}
int save = arr[0];
for(int i=1; i<5; i++){
  arr[i-1] = arr[i];
}
arr[5] = save;
save = arr[5];
for(int i=6; i<10; i++){
  arr[i-1] = arr[i];
}
arr[10] = save;
```

그리고 P는 permutation을 의미합니다. S-DES는 10비트 키를 사용해서 두 개의 8비트 sub key를 만들어냅니다. 

![bc-10](/assets/images/blockchain/bc-10.jpg)  

위 그림을 코드로 나타내면 아래와 같습니다. 

```cpp
//permutation 10 to 8
int intput[11]; // plain text
int output[11]; // output permutation
int result[11];

for(int i=1; i<=10; i++){
  cin>> input[i]; //1010000010
}

for(int i=1; i<=10; i++){
  cin>> output[i]; //1010000010
}
for(int i=1; i<=10; i++){
  result[i] = input[output[i]];
}
```

1. LS-1 : 1비트 좌로 순환 이동 연산
  - 10000 -> 00001, 01100 -> 11000


![bc-11](/assets/images/blockchain/bc-11.jpg)  

1. 1 0 0 1 0 0 1 1 1 0을 P10을 통해서 0 0 0 1 1 0 1 1 1 0으로 바꿉니다.
1. 0 0 0 1 1 0 1 1 1 0을 LF-1을 해서 0 0 1 1 0 1 1 1 0 0으로 바꿉니다.
1. 0 0 1 1 0 1 1 1 0 0을 P8해서 1 1 1 1 1 0 0 0 으로 바꿉니다. 10개에서 8로 바꾸는 permutation은 사전에 정해진 숫자(key)로 생각하면 됩니다.
1. 1 1 1 1 1 0 0 0을 LF-2gotj 1 1 0 0 0 1 0 0 1 1로 바꿉니다.
1. 이를 다시 P8해서 1 0 0 0 0 0 1 1로 바꿉니다. 

이렇게 Key1과 Key2가 만들어졌습니다.  

### Encryption

![bc-12](/assets/images/blockchain/bc-12.jpg)  


같이자는게 부담이라는 말이 별로인거지

만나는게 백프로 좋을수만은 업다 - 친구들이 빡쳐할 말이다 = 부모님한테 말하는게 부담스럽다?

혼자만의 시간이 필요하다 = 방이 두개면 되는거야?

~하면 문제없는거지. 

왔으면좋겠다 -> 일주일동안 안나갈꺼다
혼자자는거 무서워서 있었으면 좋겠다는 마음
단어선태 부담/백프로 -> 서운해서 울었다 
-> 와도됐는데 안왔다. -> 가면 좋아할껄알았다. -> 별로 신경안쓰느기분이들었다

## 문제 1

1. Employee (0,2) - works_in - (1,10) Department
2. Department (1,3) - contains - (1,1) Phone
3. Employee (1,6) - has-phone - (1,10) Phone

## 문제 2

Employee, Department, Phone를 각각 E,D,P로 표현하겠습니다.

### 풀이 1

1. Employee (1,1) - works_in - (1,1) Department
2. Department (1,1) - contains - (1,1) Phone

우선 가장 명확한 상황은 위와 같이 E,D,P가 1 : 1 : 1로 대응되는 경우입니다. 의심의 여지없이 어떤 E가 어떤 P를 어떤 D에서 사용하는지 알 수 있습니다.  

### 풀이 2

문제의 가정 사항에서 변경사항이 없을 때 다음과 같은 사항을 유추할수 있습니다.

1. 모든 P는 D에 속합니다.
2. D에서 일하지 않는 E가 있습니다.
3. 모든 E는 반드시 1개 이상의 P를 가집니다.
4. 따라서 D에서 속하지 않는 E가 P를 가질 수 있습니다.  

### 풀이 3

has-phone의 (min,max)를 유추할 수 있도록 works-in과 contains의 (min,max)를 조정하면 아래와 같습니다. 

먼저 P가 최대 10명의 E에게 속하기 위해서는 아래에 표시한 사항들이 변함이 없어야 합니다.  

1. Employee (0,2) - works_in - (1,**10**) Department
2. Department (**1**,3) - contains - (**1**,1) Phone
3. Employee (1,6) - has-phone - (1,**10**) Phone

그리고 P가 최소 1명의 E에게 속하기 위해서는 D에 최소한 명의 E가 있으면 됩니다. 

1. Employee (0,2) - works_in - (**1**,**10**) Department
2. Department (**1**,3) - contains - (**1**,1) Phone
3. Employee (1,6) - has-phone - (**1**,**10**) Phone

E가 최대 2개의 D에서 근무하고, D에 최대 3개의 P가 있다면, E가 최대 6개의 P를 갖는 것을 의미할 수 있습니다. 

1. Employee (0,**2**) - works_in - (**1**,**10**) Department
2. Department (**1**,**3**) - contains - (**1**,1) Phone
3. Employee (1,**6**) - has-phone - (**1**,**10**) Phone

문제의 가정 상황에서 drive할 수 없는 정보는 E가 반드시 하나의 P를 갖는다는 것입니다. 따라서 이와 같은 사항을 조건으로 제시했을 때 has-phone의 관계의 redundant를 삭제할 수 있습니다. 