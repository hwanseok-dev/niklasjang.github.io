---
title: "[RoadMap] Chap 1. Internet"
excerpt: "github.com/kamranahmedse/developer-roadmap"
date: 2020-05-11
categories:
  - Backend
tags:
  - Backend 
toc : true
toc_label: "=== Contents ==="
toc_icon: "heart"  # corresponding Font Awesome icon name (without fa prefix)
toc_sticky: true
classes: wide
---

본 포스팅은 [kamranahmedse의 개발자 로드맵](https://github.com/kamranahmedse/developer-roadmap)을 따라서 진행됩니다.  
---

# How does the internet work?

## 구성요소로 본 인터넷 

인터넷에 연결되는 모든 장치는 `호스트host` 혹은 `엔드 시스템end system`이라고 부릅니다. host는 `통신 링크communication link`와 `패킷 스위치packet switch`의 네트워크로 연결됩니다.  

communication link는 광케이블, 구리선 등의 물리 매체로 구성됩니다. 이때 각각의 link는 다양한 `전송률transmission rate`과 `대역폭bandwidth`를 이용해서 데이터를 전송합니다. 전송률은 초당 비트 수를 의미하는 bps(bit per second) 단위를 사용합니다. 하나의 host에서 다른 host로 데이터를 보낼 때, host는 데이터를 segment로 나누고 각 segment에 header를 붙입니다. 이렇게 만들어진 것을 `패킷packet`이라고 부릅니다. packet은 네트워크를 통해서 목적지 host로 보내진 뒤에 다시 원래의 데이터로 조립됩니다.  

packet switch는 입력 통신 링크의 하나에서 도착하는 패킷을 받아서 출력 통신 링크의 하나로 그 패킷을 전달합니다. packet switch의 종류로는 `라우터router`와 `링크 계층 스위치link-layer switch`가 있습니다. 두 형태의 스위치 모두 최종 목적지 방향으로 패킷을 전달합니다. 전자는 보통 네트워크의 중심부(코어)에서 사용되고, 후자는 access network(네트워크의 끝 단)에 사용됩니다.  

host들은 `ISP(Internet Service Provider)`를 통해서 인터넷에 접속합니다. ISP는 packet switch와 communication link로 구성된 네트워크입니다. 인터넷은 host들을 서로 연결하는 것이므로 host에 접속을 제공하는 ISP들도 서로 연결되어야 합니다.  

host, packet switch 그리고 인터넷의 다른 구성요소들은 정보의 송수신을 제어하는 여러 `프로토콜protocol`을 수행합니다. 특히 `TCP(Transmission Control Protocol)`와 `IP(Internet Protocol)`은 인터넷에서 가장 중요한 프로토콜입니다. TCP는 데이터가 전송되는 방식에 대한 규칙이고, IP는 전송되는 데이터의 포멧 규칙을 의미합니다. TCP와 IP를 합쳐 TCP/IP라고 부릅니다. 프로토콜은 둘 이상의 host 간에 교환되는 메시지 포멧과 순서뿐 아니라, 메시지의 송수신과 다른 이벤트에 따른 행동까지 정의합니다.   

## 서비스 측면에서 본 인터넷

인터넷은 app에 서비스를 제공하는 infra 구조로서의 의미를 가집니다. 수 많은 app들은 서로 데이터를 교환하는 많은 host를 포함하고 있기 때문에 `분산 앱Distributed Application`이라고 부릅니다. 중요한 것은 인터넷 app이 host에서 수행된다는 점입니다. app은 네트워크 core에서 수행되지 않습니다. packet switch들은 host간에 데이터 교환을 쉽게 해주지만 데이터의 시작과 끝안 app에는 관심을 가지지 않습니다. 인터넷에 접속된 host들은 `소켓 인터페이스socket interface`를 제공합니다. 소켓 인터페이스는 데이터를 송신파느 프로그램이 따라야 하는 규칙의 집합이며, 인터넷은 이 규칙에 따라서 데이터를 목적지 프로그램으로 전달합니다. 예를 들어 우체국을 통해서 우편을 보낼 때 이름,주소를 적고 우표를 붙히는 드으이 과정을 따르는 것이 우편 인터페이스르 따르는 것이라고 할 수 있습니다.  

## Access Network

접속 네트워크는 host를 그 host로부터 다른 먼 거리에 있는 host까지의 경로 상에 있는 첫 번째 router에 연결하는 네트워크입니다. 접속 네트워크로서 이전에는 `DSL(digital subscriber line)`을 사용했습니다. 기존에 존재하는 전화 기반 구조를 사용해서 인터넷 신호를 받아오는 방식입니다. 최근에는 `케이블 인터넷 접속`방식을 많이 사용합니다. 이는 케이블 TV 기반구조를 이용합니다. 케이블 회사가 제공하는 케이블 모뎀 안에는 `이더넷 포트`가 있는데 이것을 통해서 가정의 PC에 인터넷이 연결됩니다. 가정에서 사용하는 `LAN(local area network)`는 일반적으로 host를 가장자리 router에 연결하기 위해서 사용합니다. LAN 기술 중 가장 일반적으로 사용되는 것이 `이더넷`입니다. 이더넷 스의치 혹은 상호연결된 스위치들의 네트워크는 점점 더 큰 인터넷으로 연결됩니다. 인터넷이 글로벌 네트워킹에 대한 것이라면, 이더넷은 근거리 네트워킹에 대한 것입니다. 인터넷이 들어오는 길을 `stream`이라고 표현할 때, 보통 `다운스크림`과 `업스트림`이 구분됩니다. 전자는 가정 host에서 데이터를 받을 때, 후자는 데이터를 보낼 때 사용합니다. 일반적으로 다운스트림 채널이 업스트림 채널보다 빠른 전송속도를 가집니다. 무선 LAN 환경에서 무선 사용자들은 기업 네트워크에 연결된 Access Point로 패킷을 송신/수신하고, 이 Access point는 유선 네트워크에 다시 연결됩니다.  

## Core Network

송신 host와 수신 host 사이에서 각 패킷은 통신 링크와 패킷 스위치(router or link-layer switch)를 거치게 됩니다. 이 때 패킷은 링크의 최대 전송 속도와 같은 속도로 각각의 통신 링크상에서 전송됩니다. 따라서 송신 종단 시스템 혹은 해킷 스위치가 `R bps`의 속도로 링크상에서 `L bits`의 패킷을 송신했다면 그 패킷을 전송하는데 걸리는 시간은 `L/R초`입니다.  

대부분의 패킷 스위치는 `저장 후 전달 전송(Store and forward transmission)` 방식을 이용합니다. 이는 출력 링크로 패킷의 첫 비트를 전송하기 전에 전체 패킷을 받아야 함을 의미합니다. 송신 host에서 `L bits`짜리 패킷 `3개`개를 목적지 host로 보내는 상황을 가정해보겠습니다. 송신 host는 시간 0에 전송하기 시작합니다. `L/R`초 만에 송신 시스템은 첫 번째 전체 패킷을 전송을 완료합니다. 그리고 라우터는 `L/R초`에서 패킷을 전송하기 시작하고 목적지 host에는 `2L/R초`에 첫 번째 패킷을 전송받습니다. 따라서 `전체 지연`은 `2L/R`초입니다. 그리고 전체 패킷이 목적지에 도달할 때까지 걸리는 시간은 `4L/R`초가 됩니다.  

## 회선 교환과 패킷 교환

링크와 스위치의 네트워크를 통해 데이터를 전송시키는 방식에는 `회선 교환circuit switching`과 `패킷 교환packet switching`이라는 두 가지 기본 방식이 있습니다. 회선 교환 네트워크에서 host간에 통신을 제공하기 위해 경로상에 필요한 자원(버퍼, 링크 전송률)은 통신이 진행 중인 동안에 확보(예약)됩니다. 그리고 패킷 교환 네트워크에서는 이들 자원을 예약하지 않습니다. 대신 자원은 on-demand 방식으로 요청되고 이 때문에 통신 링크에 접속하기 위해서 기다릴 수 있습니다.  

`회선circuit`은 두 host간에 연결을 설정하기 위해서 경로 상에 있는 스위치들이 해당 연결 상태를 유지해야하는 것을 의미합니다. 연결이 이루어지는 동안 자원을 예약하기 때문에 송신자는 수신자에게 일정한 전송률로 데이터를 보낼 수 있습니다. 두 host를 연결하는 링크가 있습니다. 그리고 이 하나의 링크는 4개의 회선으로 구성된다고 가정하겠습니다. 송신 host가 하나의 라우터를 거쳐서 수신 host로 통신을 할 때 총 2개의 링크를 지나고, 이 때 각각의 링크에 속에 있는 회선 중 하나를 예약합니다. 따라서 이 연결이 진행될 때는 링크 전체 전송 용량의 1/4를 얻을 수 있습니다.  

패킷 교환 네트워크에서는 host를 잇는 링크의 자원을 예약하지 않고 packet을 주고 받습니다. 계속해서 데이터 stream을 보내는 것이 아니라 그 때 그 때 data를 packet으로 자르고 이를 전송하기 위한 자원을 잠깐 잠깐 사용합니다. 인터넷은 최대한 빠르게 패킷을 전달하려고 하지만 일정 시간 내에 전달되는 것이 보장되지는 않습니다.  

## 계층 구조

네트워크 설계자는 프로토콜을 계층적으로 조직했습니다. 한 계층이 상위 계층에 제공하는 서비스에 관심을 갖고, 이것을 계층의 `서비스 모델`이라고 합니다. 예를 들어서 공항에서 `티켓팅`을 할 때 `수하물 검사`의 과정은 자세히 알지 않고 `수하물 검사 서비스`를 진행하는 것에만 집중합니다. `수하물 검사`를 진행하는 부서에서는 `수하물의 운반`의 과정은 알지 못하고 `수하물 운반 서비스`를 사용해서 `수하물 검사 서비스`를 제공합니다. 네트워크를 구성하는 하드웨어와 소프트웨어를 계층적으로 구분한 것이 `프로토콜 스택protocol stack`입니다.  

5개 계층의 인터넷 프로토콜 스택은 다음과 같습니다.

1. 애플리케이션
  - 네트워크 App과 애플리케이션 계층의 protocol이 존재합니다.
  - HTTP, SMTP, FTP와 같은 프로토콜을 포함합니다.
  - 정보 패킷 : Message
1. 트랜스포트
  - 클라이언트와 서버 간에 애플리케이션 계층의 미시지를 전송하는 서비스를 제공합니다. 
  - TCP, UDP를 포함합니다. 
  - TCP는 긴 메시지를 짧은 메시지로 나누고 혼잡제어 기능을 제공합니다. 네트워크가 혼잡할 때는 출발지의 전송속도를 줄입니다.
  - UDP는 비연결형 서비스를 제공합니다. 신뢰성, 흐름제어, 혼잡제어의 기능을 제공하지 않습니다.
  - 정보 패킷 : Segment
1. 네트워크
  - 정보 패킷 : datagram
  - 트랜스포트 계층은 Segment와 목적지 주소를 네트워크 계층으로 전송합니다. 
  - 네트워크 계층은 Segment와 목적지 주소를 받아서 Segment를 datagram로 나눈 뒤 routing하는 역할을 맡습니다. 
  - IP를 포함합니다.
1. 링크
  - 링크 계층은 datagram을 경로상의 다음 노드에 전달합니다.
  - 정보 패킷 : frame
1. 물리
  - frame 내부의 각 bit를 한 노드에서 다른 노드로 전송시킵니다.

OSI 7개 계층의 프로토콜 스택은 다음과 같습니다.

1. 애플리케이션
1. 프레젠테이션
  - 애플리케이션들이 교환되는 데이터의 의미를 해석하도록 하는 서비스를 제공합니다. 
  - 데이터 기술 뿐만 아니라 `데이터 압축`과 `데이터 암호화`를 포함합니다.
1. 세션
  - 데이터 교환의 경계와 `동기화`를 제공합니다.
1. 트랜스포트
1. 네트워크
1. 링크
1. 물리

# What is HTTP?

HTTP는 애플리케이션 계층에서 사용되는 프로토콜이기 때문에 애플리케이션 계층에 대한 간략한 이해를 포함해서 진행하겠습니다.  

## 네트워크 애플리케이션의 원리

어떤 앱을 만들 때 라우터나 링크 계층 스위치 같이 네트워크 코어 장비에서 실행되는 소프트웨어를 작성할 필요는 없습니다. 이러한 내용은 애플리케이션 계층에서 기능하지 않는 대신 네트워크 계층 및 그 하위 계층에서 기능합니다. 앱 개발자는 `네트워크 구조`는 고정되어 있음을 가정합니다. 대신에 `애플리케이션 구조`는 앱 개발자에 의해서 설계되고 다양한 host에서 어떻게 조직되어야하는 지를 지시합니다.  

`클라이언트-서버 구조`에서 항상 켜져 있는 host는 `서버`이고, 이 서비스는 `클라이언트`라는 많은 host의 요청을 받습니다. 클라이언트-서버 구조에서 이들은 서로 직접적으로 통신하지 않습니다. 예를 들어서 웹 앱에서는 두 개의 브라우저가 직접적으로 통신하지 않습니다. 그리고 클라-서버 구조에서는 서버가 고정 IP 주소라는 잘 알려지 주소를 사용합니다. 서버는 항상 동작하기 때문에 클라이언트는 서버 주소로 패킷을 보내서 항ㅅ아 서버에 연결할 수 있습니다. 하나의 서버에 수 많은 클라가 접속된다면 서버가 모든 클라에 응답하지 못할 수 있습니다. 그래서 구글같은 거대하 기업은 `데이터 센터`를 두어서 수십만개의 서버를 갖추고 있습니다.  

`P2P 구조`에서는 항상 켜져 있는 기반 구조 서버에 최소로 의존합니다.(혹은 전혀 의존하지 않습니다.) 대신에 앱은 `Peer`라는 간헐적으로 연결된 호스트 쌍이 직접 통신합니다. 여러 링크 경로를 지나서 데이터가 서버에 닿았다가 다시 목적지 host로 가는 것이 아니라, 바로 목적지 host로 가는 것을 말합니다. P2P 구조의 특징은 `자가 확장성self-scalability`입니다. 예를 들어서 P2P 파일 공유 앱에서 비록 각 피어들이 파일을 요구함으로써 작업 부하를 만들어내지만, 각 피어들은 또한 파일을 다른 피어들에게 분배함으로써 그 시스템에 서비스 능력을 추가합니다. P2P는 고도의 분산 구조적 특성으로 보안과 성능 이슈가 존재합니다.  

## Session 

`세션Session`의 사전적인 정의는 다음과 같습니다.

1. 네트워크 환경에서 사용자 간 또는 컴퓨터 간의 대화를 위한 논리적인 연결.
1. 프로세스들 사이에서 통신을 하기 위해서 메시지 교환을 통해 서로를 인식한 후 이후부터 통신을 마칠 때까지의 기간.

좀 더 쉽게 설명하면 아래와 같습니다.  

1. 일정 시간동안 같은 사용자(정확하게는 브라우저)로부터 들어오는 일련의 요구를 하나의 상태로 보고 그 상태를 일정하게 유지시키는 기술
1. 일정 시간이란 방문자가 웹 브라우저를 통해 웹 서버에 접속한 시점으로부터 웹 브라우저를 종료함으로써 연결을 끝내는 시점

## Cookie

`쿠키`는 방문자의 정보를 방문자 컴퓨터의 메모리에 저장하는 것을 말합니다. 예를 들면 ID나 비밀번호를 저장하거나 방문한 사이트를 저장할 때 사용합니다.  

`세션`은 방문자의 요청에 따른 정보를 방문자 메모리에 저장하는 것이 아니라, 웹 서버가 세션 아이디 파일을 만들어 서비스가 돌아가고 있는 서버에 저장하는 것을 말합니다.  

## 클라이언트와 서버

두 프로세스 간의 통신 세션에서 통신을 초기화하고(다른 프로세스와 세션을 시작하려고 접속을 초기화)하는 프로세스를 `클라이언트`라고 하고, 세션을 시작하기 위해 접속ㅇ르 기다리는 프로세스를 `서버`라고 합니다. 

## Socket

하나의 프로세스로부터 다른 프로세스로 보내는 메시지는 네트워크를 통해 움직입니다. 프로세스는 `소켓Socket`을 통해서 네트워크로 메시지를 보내고 받습니다. 소켓은 집의 `문`과 같은 역할을 합니다. 프로세스가 메시지를 다른 호스트의 프로세스로 보내고 싶을 떄, 메시지를 보내는 socket으로 보냅니다.  

소켓은 host의 애플리케이션 계층과 트랜스포트 계층 간의 인터페이스 입니다. 또한 소켓은 네트워크 애플리케이션이 인터넷에 만든 프로그래밍 인터페이스이므로, 애플리케이션과 네트워크 사이의 `API(Application Programming Interface)`라고도 합니다.  

## IP, port number

데이터를 보낼 때 어떤 호스트의 어떠 프로세스로 보낼지를 결정해야합니다. IP는 호스트를 식별할 때 사용되고, port number는 호스트의 프로세스를 식별할 때 사용됩니다.  

## HTTP Session

세션은 서버가 해당 서버로 접속한 클라이언트를 식별하는 방법입니다. 서버는 접근한 클라이언트에게 `response-header field`인 `set-cookie`값으로 클라이언트 식별자인 `session-id`를 발행합니다. 서버가 Session id를 만든다고 보면 됩니다. 서버로부터 발행된 session-id는 해당 서버와 클라이언트 메모리에 저장됩니다. 이 때 클라이언트 메모리에 사용되는 cookie는 Session이 종료될 때 같이 소멸되는 `Memory Cookie`가 사용됩니다.  

HTTP Session의 동작 순서는 아래와 같습니다.  

1. 클라이언트가 서버로 접속(http요청)을 시도합니다.
1. 서버는 접근한 클라이언트의 `request-header field`인 `cookie`를 확인해 클라이언트가 해당 session-id를 보내왔는지 확인합니다.
1. 만약 클라이언트로부터 전송된 session-id가 없으면, 서버는 session-id를 생성해서 클라이언트에게 `response-header field`인 `set-cookie`값으로 session-id를 보내줍니다. 

## HTTP 개요

HTTP는 웹의 애플리케이션 계층 프로토콜입니다. HTTP는 클라이언트 프로그램과 서버 프로그램으로 구현됩니다. 서로 다른 종단 시스템에서 수행되는 두 프로그램은 서로 HTTP 메시지를 교환하여 통신합니다. HTTP는 통신되는 메시지가 어떤 구조를 가지고 어떻게 통신되는지를 정의합니다.  

`웹 페이지`는 여러 객체들로 구성됩니다. 객체는 단일 URL로 지정할 수 있는 하나의 파일입니다. 예를 들면 HTML, JPEG, GIF 이미지 등입니다. 대부분의 웹페이지는 기본 HTML 파일과 여러 참조 객체로 구성됩니다. 기본 HTML 파일은 페이지 내부의 다른 객체를 그 객체의 URL로 참조합니다.  

각 URL은 두 가지 요소로 구성됩니다. 객체를 갖고 있는 서버의 `host name`과 `객체의 경로이름`입니다.  

[https://github.com/niklasjang/niklasjang.github.io/blob/master/assets/images/ml/cnn-0.jpg](https://github.com/niklasjang/niklasjang.github.io/blob/master/assets/images/ml/cnn-0.jpg)  

다음과 같은 URL이 있을 때 https://github.com은 호스트 네임이고 나머지는 경로 이름입니다. `웹 브라우저`는 HTTP의 클라이언트 측을 구현합니다. 따라서 웹의 관점에서 브라우저와 클라이언트라는 용어는 혼용되서 사용됩니다. `웹 서버`는 HTTP의 서버측을 구현합니다. 웹 서버는 URL로 각각 지정할 수 있는 웹 객체를 가지고 있습니다. 인기 있는 웹 서버로는 아파치가 있습니다.  

# Browers and how they work?

## HTTP 요청

HTTP는 웹 클라이언트가 웹 서버에게 웹 페이지를 어떻게 요청하는지와 서버가 클라이언트로 어떻게 웹 페이지를 전송하는지를 정의합니다. 사용자가 웹 페이지를 요청할 때, 브라우저는 페이지 내부의 객체에 대한 HTTP 요청 메시지를 서버에 보냅니다. 서버는 요청을 수신하고 객체를 포함하는 HTTP 응답 메시지를 보냅니다.  

HTTP는 TCP를 전송 프로토콜로 사용합니다. HTTP 클라이언트는 먼저 서버에 TCP 연결을 시작합니다. 일단 연결이 이루어지면, 브라우저와 서버 프로세스는 그들의 소켓 인터페이스를 통해 TCP로 접속합니다. 클라이언트 측에서 보면 소켓은 클라이언트 프로세스와 TCP 연결 사이의 출입구이고, 서버 측에서 보면 소켓은 서버 프로세스와 TCP 연결 사이의 출입구입니다.  

클라이언트는 HTTP 요청 메시지를 소켓으로 보내고, 응답 메시지를 받을 때도 소켓으로 받습니다. 마찬가지로 HTTP 서버도 같습니다. HTTP는 전송 프로토콜로 TCP를 사용하고, TCP는 신뢰적인 통신을 보장합니다. 데이터가 목적지로 도착하는 것을 보장하는 서비스를 제공하는 것입니다. 따라서 클라이언트 프로세스가 발생시킨 모든 HTTP 요청 메시지가 궁극적으로 서버에 잘 도착한다는 것을 의미합니다.  

서버가 클라이언트에게 요청 정보는 보낼 때, 서버는 클라이언트에 관한 어떤 정보도 저장하지 않습니다. 만약 같은 정보를 여러번 요청해도 아까 그 파일을 보냈다는 신호를 보내지 않도 매번 새로 보내줍니다.  

## 비지속 연결과 지속 연결

클라이언트와 서버가 통신할 때는 수 많은 데이터를 요청하고 응답합니다. 이때 각각의 요청이 분리된 TCP 연결을 통하면 `비지속 연결non-persistent connection`이라고 하고, 모두 같은 TCP 연결을 통해서 수행되면 `지속 연결`이라고 합니다. HTTP는 default 값으로 지속연결을 사용합니다.  

아래는 비지속 연결의 과정을 보여줍니다.

1. 클라이언트와 서버에는 각각 TCP 연결을 위한 소켓이 존재합니다.
1. HTTP 클라이언트는 HTTP 기본 포트인 80을 통해 HTTP 서버로 TCP 연결을 시도합니다.
1. HTTP 서버는 HTTP 클라이언트의 TCP 연결에 응답합니다.
1. TCP 연결이 완료됩니다.
1. HTTP 클라이언트는 연결된 TCP 통신을 통해 요청 메시지를 전송합니다.
1. HTTP 서버는 연결된 TCP 통신을 통해 요청 메시지를 받습니다.
1. HTTP 서버는 저장장치로부터 요청 받은 객체를 추출하고 응답 메시지에 캡슐화합니다. 
1. HTTP 서버는 응답 메시지를 소켓을 통해 HTTP 클라이언트에게 전송합니다.
1. HTTP 서버는 TCP에게 TCP 연결을 끊으라고 합니다.
1. HTTP 클라이언트가 응답 메시지를 받으면 TCP 연결이 중단됩니다. 캡슐화된 객체를 추출하고 객체에 대한 참조를 사용자에게 보여줍니다.  

위 과정을 객체를 요청받을 때마다 반복해서 진행합니다. 기본적으로 브라우저는 default로서 5~10개의 TCP 연결을 통시에 설정하고 각 연결은 하나의 요청/응답을 처리합니다. 설정을 바꾸면 1개의 TCP 연결만을 설정하고 10개의 요청을 지속적으로 처리할 수도 있습니다. 

## HTTP 요청 메시지 포멧

```txt
GET /somedir/page.html HTTP/1.1
Host : www.someschool.edu
Connectoin : close
User-agent : Mozilla/5.0
Accept-language : fr
```

위는 기본적인 HTTP 요청 메시지의 포멧을 보여줍니다. 첫 째, ASCII 텍스트로 쓰여있어서 사람이 읽을 수 있습니다. 둘 째, 메시지의 각 줄은 Carriage return & line feed로 구별됩니다. 셋 째, 첫 줄은 `request line`이라고 부르고 나머지는 `header line`이라고 부릅니다.  

요청 라인은 `method`, `URL`, `HTTP 버전`으로 구성됩니다. method에는 GET, POST, HEAD, PUT 등이 올 수 있습니다. HTTP 메시지의 대부분은 GET을 사용합니다. GET 방식은 브라우저가 URL 필드로 식별되는 객체를 요청할 때 사용합니다.  

헤더라인은 객체가 존재하는 호스트를 명시하고 있습니다. 이미 서버와 TCP connection이 연결된 뒤에 주고 받는 HTTP 메시지 이지만 서버의 Host name이 여전히 명시되어 있습니다. 이 부분은 `웹 프록시 캐시`에서 필요로 합니다.  

conncection은 서버에게 지속 연결 사용을 원하지 않는 것을 며이합니다.(브라우저는 서버가 요청 객체를 보낸 후에 TCP 연결을 닫기를 원합니다.)  

User-agent는 서버에게 요청을 보내는 브라우저의 타입을 명시합니다.  

Accept-language는 사용자가 객체의 프랑스어 버전을 원하고 있음을 나타냅니다. 만약 특정 언어버전이 없다면 기본 버전을 보냅니다.  

![backend-0](/assets/images/backend/backend-0.jpg)  

GET 방식에서는 객체 몸체가 비어있고, POST 방식에서는 사용됩니다. 사용자가 form에 내용을 채워넣을 때(검색을 할 때) POST 방식을 사용합니다. 


## HTTP 응답 메시지 포멧

```txt
HTTP/1.1 200 OK
Connection : close
Data : Tue, 18 Aug 2015 15:44:04 GMT
Server: Apache/2.2.3 (CentOS)
Last-Modified: Tue, 18 Aug 2015 15:11:03 GMT
Content-Length: 6821
Content-type : text/html

```

![backend-1](/assets/images/backend/backend-1.jpg)  

1. Connection : close : 클라이언트에게 메시지를 보낸 후 TCP 연결을 닫는 지속 연결을 의미합니다.
1. Date : HTTP응답이 서버에 의해서 생성되고 보낸 날짜와 시간입니다. 이 시간이 객체가 생성되거나 마지막으로 수정된 시간이 아닙니다. 서버가 파일 시스템으로부터 객체를 추출하고 응답 메시지에 그 객체를 삽입하여 응답 메시지를 보낸 시간을 의미합니다.
1. Server : 메시지가 아파치 웹 서버에 의해서 만들어졌음을 의미합니다.

상태 코드와 문장에 대한 추가 설명입니다.  

1. 200 OK : 요청이 성공되었고, 정보가 응답으로 보내졌습니다.
1. 301 Moved Permanently : 요청 객체가 영원히 이동되었습니다. 새로운 URL은 응답 메시지의 Location: 헤더에 나와있습니다. 클라이언트 소프트웨어는 자동으로 이 새로운 URL을 추출합니다. 
1. 400 Bad Request : 서버가 요청을 이해할 수 없다는 일반 오류 코드입니다.
1. 404 Non Found : 요청 문서가 서버에 존재하지 않습니다.
1. 505 HTTP Version Not Supported : 요청 HTTP 프로토콜 버전을 서버가 지원하지 않습니다.  

# DNS and how it works?

# What is Domain Name?

# What is hosting?

