---
title: "[RoadMap] Chap 0. Internet(Transport layer)"
excerpt: "github.com/kamranahmedse/developer-roadmap"
date: 2020-05-11
categories:
  - Backend
tags:
  - Backend 
toc : true
toc_label: "=== Contents ==="
toc_icon: "heart"  # corresponding Font Awesome icon name (without fa prefix)
toc_sticky: true
classes: wide
---

본 포스팅은 [kamranahmedse의 개발자 로드맵](https://github.com/kamranahmedse/developer-roadmap)을 따라서 진행됩니다.  
---

Application Layer은 네트워크 애플리케이션과 애플리케이션 계층 프로토콜이 있는 곳이라고 설명했습니다. HTTP가 바로 애플리케이션 계층에서 동작하는 프로토콜입니다.**(만약 애플리케이션 계층 프로토콜로 RTMP를 사용하는 경우 목적지 URL이 rtmp://로 시작합니다. 즉, HTTP는 사용되지 않습니다.)** 트랜스포트 계층은 클라이언트와 서버 사이에 애플리케이션 계층 메시지를 전달하는 서비스를 제공합니다. 그런데 HTTP와 같은 애플리케이션 메시지가 어떻게 TCP 소켓에서 전송되는지 알지 못해서 뒤의 내용이 깊게 이해되지 않습니다. 그래서 트랜스포트 계층에 대한 이론을 짚고 넘어가겠습니다.  

# 트랜스포트 계층 서비스 및 개요

트랜스포트 계층 프로토콜은 서로 다른 호스트에서 동작하는 애플리케이션 프로세스 간의 `논리적인 통신logical communications`을 제공합니다. 논리적 통신은 애플리케이션의 관점에서 보면 프로세스들이 동작하는 호스트들이 직접 연결된 것처럼 보인다는 것을 의미합니다. 애플리케이션 프로세스는 메시지 운반에 사용되는 물리적인 하위 구조의 세부 사항에 상관없이 서로 메시지를송신하기 위해서 트랜스포트 계층에서 제공하는 논리적인 통신을 사용합니다.  

트랜스포트 계층 프로토콜은 네트워크 라우터가 아닌 종단 시스템에서 구현됩니다. 송신 측의 트랜스포트 계층은 송신 애플리케이션 프로세스로부터 수신한 메시지를 (송신측에도 트랜스포트 계층이 있음을 주목), 트랜스포트 계층 `세그먼트segment`인 트랜스포트 계층 패킷으로 변환합니다. 이러한 변환은 애플리케이션 메시지를 트랜스포트 계층 세그먼트로 만들기 위해서 작은 조각을 분할하고, 각각의 조각에 트랜스포트 계층 헤더를 추가함으로써 수행됩니다. 그런 후에 트랜스포트 계층은 송신 종단 시스템에 있는 네트워크 계층으로 세그먼트를 전달하고, 여기서 세그먼트가 네트워크 계층 패킷(datagram)안에 캡슐화되어 목적지로 전달됩니다. 네트워크 라우터는 오로지 datagram의 네트워크 계층 필드에 대해 동작한다는 것에 유념합니다. (즉, 라우터는 데이터 그램과 함꼐 캡슐화된 트랜스포트 계층 세그먼트의 필드를 검사하지 않습니다.) 수식 측에서, 네트워크 계층은 데이터그램으로부터 트랜스포트 계층 세그먼트를 추출하고, 트랜스포트 계층으로 세그먼트를 보냅니다. 이후 트랜스포트 계층은 수신 애플리케이션에서 세그먼트 내부의 데이터를 이용할 수 있도록 수쉰된 세그먼트를 처리합니다.  

## 트랜스포트 계층과 네트워크 계층 사이의 관계

트랜스포트 계층 프로토콜은 서로 다른 호스트에서 동작하는 `프로세스`들 사이의 논리적인 통신을 제공합니다. 네트워크 계층 프로토콜은 ` 호스트`들 사이의 논리적인 통신을 제공합니다.  

TCP/IP 네트워크는 애플리케이션 계층에게 두 가지 트랜스포트 계층 프로토콜을 제공합니다. 하나는 UDP로 비신뢰적이고 비연결형인 서비스이고, 나머지 하나는 TCP로 신뢰적인 연결지향적인 서비스입니다. IP 서비스 모델은 호스트들 간에 논리적인 통신을 제공하는 최선형 전달 서비스(best-effort delivery service)입니다. 최대한 노력하지만 어떠한 보장도 하지 않는 것을 의미합니다. 특히 IP는 세그먼트의 전달을 보장하지 않고, 세그먼트가 순서대로 전달되는 것을 보장하지 않습니다.  또한 IP는 세그먼트 내부 데이터의 무결성을 보장하지 않습니다. 이러한 이유 때문에 IP는 `비신뢰적인 서비스`라고 부릅니다. 트랜스포트 계층을 설명할 때는 각 호스트가 적어도 하나의 IP 주소를 가지고 있다고 가정합니다.  

UDP와 TCP의 가장 기본적인 기능은 '종단 시스템 사이의 IP 전달 서비스'를 '종단 시스템에서 동작하는 두 프로세스 간의 전달 서비스'로 확장하는 것입니다. 즉, `호스트 대 호스트` 전달을 `프로세스 대 프로세스` 전달로 확장하는 것이고 이를 `트랜스포트 다중화 transport multiplexing`와 `역다중화demultiplexing`이라고 부릅니다. UDP와 TCP는 헤더에 오류 검출 필드를 포함해서 무결성 검사를 제공합니다. 지금까지 설명한 `프로세스 대 프로세스 데이터 전달`과 `오류 검출`은 UDP가 제공하는 유일한 두 가지 서비스입니다.  

TCP는 UDP의 기능에 더해 `신뢰적인 데이터 전달reliable data transfer`를 제공합니다. 흐름제어, 순서번호, 확인응답, 타이머를 사용함으로써 TCP는 송신하는 프로세스로부터 수신하는 프로세스에게 데이터가 순서대로 정확하게 전달되도록 확실하게 합니다. 특히, TCP는 `혼잡제어congestion control`을 사용합니다. 혼잡제어는 인터넷에 대한 통상적인 서비스같이 애플리케이션이 야시 시켜서 제공되는 특정 서비스가 아니라, 전체를 위한 일반 서비스입니다. 예를 들어 한 TCP 연결이 과도한 양의 트래픽으로 모든 통신하는 호스트들 사이의 스위치와 링크를 폭주되게 하는 것을 방지합니다.  

## 다중화와 역다중화

`호스트 대 호스트` 전달을 `프로세스 대 프로세스` 전달로 확장하는 과정을 살펴봅니다. 목적지 호스트에서이 트랜스포트 계층은 바로 아래의 네트워크 계층으로부터 세그먼트를 수신합니다. 트랜스포트 계층은 호스트에서 동작하는 해당 애플리케이션 프로세스에게 이 세그먼트의 데이터를 전달하는 의무를 가집니다. 예를 들어서 제 컴퓨터에서 하나의 FTP 세션과 2개의 텔넷 세션을 실행하면서 웹 페이지를 다운로드 하고 있다고 가정하면, 저는 동작중인 4개의 네트워크 애플리케이션 프로세스를 갖습니다.(텔넷 2개, FTP 1개, HTTP 1개) 제 컴퓨터의 트랜스포트 계층이 하위 네트워크 계층으로부터 데이터를 수신할 때, 트랜스포트 계층은 이들 4개의 프로세스 중 하나에게 수신한 데이터를 전달할 필요가 있습니다.  

네트워크 애플리케이션의 한 부분으로서 프로세스는 소켓을 가집니다. 이를 통해서 네트워크에서 프로세스로의 데이터를 전달하며, 프로세스로부터 네트워크로 데이터를 전달하는 출입구 역할을 합니다. 따라서 수식 측 호스트의 트랜스포트 계층은 실제로 데이터를 직접 프로세스로 전달하지 않습니다. 대신에 중간 매개자인 소켓(애플리케이션 계층과 트랜스포트 계층 사이의)에게 전달합니다. 어떤 주어진 ㅅ ㅣ간에 수신 측 호스트에 하나 이상의 소켓이 있을 수 있으므로, 각각의 소켓은 어떤 하나의 유잃나 식별자를 가집니다. 이 식별자의 포멧은 UDP인지 TCP인지에 따라서 달라집니다.  

적절한 소켓을 찾는 방법은 다음과 같습니다. 각각의 트랜스포트 계층 세그먼트는 소켓을 찾기 위해 세그먼트에 필드 집합을 가지고 있습니다. 수신 측의 트랜스포트 계층은 수신 소켓을 식별하기 위해서 이들 필드를 검사합니다. 그리고 해당 세그먼트를 적절한 소켓으로 보냅니다. 트랜스포트 계층 세그먼트의 데이터를 올바른 소켓으로 전달하는 작업을 `역다중화demultiplexing`이라고 합니다. 출발지 호스트에서 소켓으로부터 데이터를 모으고 이에 대한 세그먼트를 생성하기 위해서 각 데이터에 헤더 정보로 캡슐화하고, 그 세그먼터들을 네트워크 계층으로 전달하는 작업을 `다중화multiplexing`이라고 합니다.  

이제 다중화와 역다중화의 개념을 이했으므로 실제로 호스트에서 어떻게 수행되는지 살펴보겠습니다. 트랜스포트 계층 다중화에는 다음 두 가지 요구 사항을 가지고 있음을 알 수 있습니다. 첫째, 소켓은 유일한 식별자를 갖습니다. 둘째, 각 세그먼트는 세그먼트가 전달될 적절한 소켓을 가리키는 특별한 필드를 가지고 있습니다. 이 특별한 필드라는 것이 `출발지 포트 번호 필드`와 `목적지 포트 번호 필드`입니다. 

### 비연결형 에서의 다중화와 역다중화

```python
clientSocket = socket(AF_INET, SOCK_DGRAM)
```

위 코드는 UDP 소켓을 생성합니다. UDP 소켓이 생셩될 때 트랜스포트 계층은 포트 번호를 소켓에게 자동으로 할당합니다. 특히 트랜스포트 계층은 현재 호스트에서 UDP 포트로 사용하지 않는 1024~65535 사이의 포트 변호를 할당합니다. 반면에 우리는 소켓을 생성한 뒤에, 특정 포트 번호(여기서는 19157)를 UDP 소켓에 할당하기 위해서 아래와 같이 합니다. 

```python
clientSocket.bind(('', 19157))
```

만약 코드를 작성하는 애플리케이션 개발자가 잘 알려진 프로토콜의 서버 측을 구현하고 있다며, 개발자는 상응하는 잘 알려진 포트 번호를 할당해야 합니다. 일반적으로 애플리케이션 서버 측이 특정 포트 번호를 할당하는 것에 반하여, 애플리케이션 클라이언트 측은 트랜스포트 계층이 포트 번호를 자동으로 할당해서 위와 같은 bind를 진행하지 않아도 됩니다.  

호스트의 트랜스포트 계츠은 애플리케이션 데이터, 출발지 포트 번호, 목적지 포트 번호, 그리고 나중에  설명할 2개의 값을 묶어서 트랜스포트 계층 세그먼트를 생성합니다. 그리고 네트워크 계층으로 전달합니다. 네트워크 계층은 세그먼트를 IP datagram으로 캡슐화하고 최선형 전달 서비스로 수신 호스트로 전달합니다. 수신 호스트는 datagram을 받아서 segment를 검사해서 목적지 포트 번호를 찾고 적절한 소켓에 전달합니다.  

# 연결지향형 다중화와 역다중화

//TODO 책 180page

//select epoll 비교 : https://ozt88.tistory.com/21

[poll](https://vigorfintech.wordpress.com/2018/10/31/springboot2-0-webflux-eventloop/)
poll은 거의 select와 동일하지만 다음과 같은 차이가 있다.

관리 file descriptor 무제한.
좀더 low level의 처리로 system call의 호출이 select보다 적음. 이식성 나쁨.
접속수가 늘어나면 오히려 fd당 체크 마스크의 크기가 select는 3bit인데 비해, poll은 64bit정도이므로 양이 많아지면 성능이 select보다 떨어짐.