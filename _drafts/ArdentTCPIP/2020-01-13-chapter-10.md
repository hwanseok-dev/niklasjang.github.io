# 10 멀티프로세스 기반의 서버 구현

- 프로세스 : 실행 중인 프로그램
- 멀티프로세스 기반 서버 : 다수의 프로세스를 생성하는 방식으로 서비스 제공
    - 쿼드 코어 : 4개의 연산장치가 존재하는 CPU
    - 코어의 수만큼 프로세스를 동시에 실행시킬 수 있다.
    - 코어의 수를 넘어서는 프로세스가 생성되면, 프로세스 별로 코어에 할당되는 시간이 나뉜다.
- 멀티플렉싱 기반 서버 : 입출력 대상을 묶어서 관리하는 방식으로 서비스 제공
- 멀티쓰레딩 기반 서버 : 클라이언트의 수만큼 쓰레드를 생성하는 방식으로 서비스 세공

fork 함수 호출을 통한 프로세스의 생성

```c
#include <unistd.h>

pid_t fork(void);
```

fork 함수는 호출한 프로세스의 복사본을 생성한다. 즉, 이미 실행 중인 프로세스를 복사하는 것이다. 이후 두 프로세스 모두 fork 함수의 호출 이후 문장을 실행하게 된다. 그런데 완전히 도일한 프로세스로 메모리 영역까지 동일하게 복사하기 때문에 이후의 프로그램 흐름은 fork 함수의 반환 값을 기준으로 나뉘도록 프로그래밍 해야한다. 즉, fork 함수의 다음 특징을 이용해서 프로그램의 흐름을 구분해야 한다.

- 부모 프로세스 : fork 함수의 반환값은 자식 프로세스의 PID
- 자식 프로세스 : fork 함수의 반환값은 0

```c
//부모 프로세스
int gval = 10;
int main (void){
    int lval = 20;
    lval += 5;
    gval++;
    pid_t pid=fork();
    if(pid == 0){
        gval++;
    }else{
        lval++; //실행됨
        ...
   }
}
```

```c
//자식 프로세스
//gval은 11로 복사
int main (void){
    //lval은 25로 복사
    . . . .

    pid_t pid = fork();
    if(pid==0){
        gval++; //실행됨
    }else{
        lval++;
    }
}
```

좀비 프로세스의 생성이유  

좀비 프로세스의 생성 이유를 먼저 살펴보자. fork() 함수의 호출로 생성된 자식 프로세스가 종료되는 상황 두 가지를 예로 들면 다음과 같다.

1. 인자로 전달하면서 exit를 호출하는 경우
1. main 함수에서 return 문을 실행하면서 값을 반환하는 경우

exit()과 main의 return에 의해서 반환되는 값 모두 운영체제로 전달된다. 그리고 운영체제는 이 값이 자식 프로세스를 생성한 부모 프로세스에게 전달될 때까지 자식 프로세스를 소멸시키지앟는다. 이 상황의 프로세스를 좀비 프로세스라고 한다. 바꿔말하면,  

> 해당 자식 프로세스를 생성한 부모 프로세스에게 exit 함수의 인작밧이나 return 문의 반호나값이 전달되어여 한다.  

```c
//좀비 프로세스 만들기 예제
#include <stdio.h>
#include <unistd.h>

int main(int argc, char *argv[])
{
	pid_t pid=fork();
	
	if(pid==0)     // if Child Process
	{
		puts("Hi I'am a child process");
	}
	else
	{
		printf("Child Process ID: %d \n", pid);
		sleep(30);     // Sleep 30 sec.
	}

	if(pid==0)
		puts("End child process");
	else
		puts("End parent process");
	return 0;
}
``` 

좀비 프로세스의 상태는 콘솔에서 `ps au`를 치고 STATUS가 z+인 것을 찾으면 된다.  

